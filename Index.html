<script>
/* ===== Medallion Forge — Enhanced Edition (fixed helpers + Eruda bootstrap) ===== */
(() => {
  'use strict';

  // --- helpers (fixed) -------------------------------------------------------
  const $  = s => document.querySelector(s);                 // single
  const $$ = s => Array.from(document.querySelectorAll(s));  // many
  const byId = id => document.getElementById(id);
  const NS = 'http://www.w3.org/2000/svg';
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Quietly init Eruda if it's present (prevents console spam)
  if (window.eruda && typeof window.eruda.init === 'function') {
    try { window.eruda.init(); } catch { /* no-op */ }
  }

  // --- storage ---------------------------------------------------------------
  const STORAGE_KEYS = {
    FORM: 'medallion:enhanced:form',
    PRESETS: 'medallion:enhanced:presets',
    THEME: 'medallion:enhanced:theme',
    VIEW: 'medallion:enhanced:view'
  };
  const storage = {
    get: k => { try { return localStorage.getItem(k) } catch { return null } },
    set: (k, v) => { try { localStorage.setItem(k, v) } catch {} },
    del: k => { try { localStorage.removeItem(k) } catch {} }
  };

  // --- toast -----------------------------------------------------------------
  const toastContainer = byId('toastContainer');
  let toastId = 0;
  const showToast = (message, type = 'success', duration = 3000) => {
    const el = document.createElement('div');
    el.className = `toast ${type} show`;
    el.id = `toast-${++toastId}`;
    el.innerHTML = `
      <div style="display:flex;align-items:center;gap:10px">
        <span class="material-icons-round">
          ${type === 'success' ? 'check_circle' : type === 'error' ? 'error' : 'info'}
        </span>
        <span>${message}</span>
      </div>`;
    toastContainer.appendChild(el);
    byId('live').textContent = message;
    setTimeout(() => {
      el.style.opacity = '0';
      el.style.transform = 'translateX(100%) scale(0.95)';
      setTimeout(() => el.remove(), 200);
    }, duration);
  };

  // --- theme -----------------------------------------------------------------
  function initTheme() {
    const stored = storage.get(STORAGE_KEYS.THEME);
    if (stored === 'light') document.body.classList.add('theme-light');

    const updateTheme = () => {
      const isLight = document.body.classList.contains('theme-light');
      const toggle = byId('themeToggle');
      const icon = toggle.querySelector('.material-icons-round');
      const label = byId('themeLabel');
      toggle.setAttribute('aria-pressed', String(isLight));
      icon.textContent = isLight ? 'light_mode' : 'dark_mode';
      label.textContent = isLight ? 'Light' : 'Dark';
      byId('stage').classList.toggle('light', isLight);
    };

    updateTheme();
    byId('themeToggle').addEventListener('click', () => {
      const isLight = document.body.classList.toggle('theme-light');
      storage.set(STORAGE_KEYS.THEME, isLight ? 'light' : 'dark');
      updateTheme();
      showToast(`Switched to ${isLight ? 'Light' : 'Dark'} theme`);
    });
  }

  // --- tabs (uses $$) --------------------------------------------------------
  function initTabs() {
    const tabs = $$('.tab');
    const panels = {
      basic: byId('panel-basic'),
      symbols: byId('panel-symbols'),
      advanced: byId('panel-advanced'),
      export: byId('panel-export')
    };

    const setTab = (activeTab) => {
      const targetId = activeTab.dataset.tab;
      tabs.forEach(tab => {
        const on = tab === activeTab;
        tab.setAttribute('aria-selected', String(on));
        tab.tabIndex = on ? 0 : -1;
      });
      Object.entries(panels).forEach(([id, panel]) => { panel.hidden = id !== targetId; });
      activeTab.focus();
    };

    tabs.forEach((tab, index) => {
      tab.addEventListener('click', () => setTab(tab));
      tab.addEventListener('keydown', e => {
        switch (e.key) {
          case 'ArrowRight': e.preventDefault(); setTab(tabs[(index + 1) % tabs.length]); break;
          case 'ArrowLeft':  e.preventDefault(); setTab(tabs[(index - 1 + tabs.length) % tabs.length]); break;
          case 'Home':       e.preventDefault(); setTab(tabs[0]); break;
          case 'End':        e.preventDefault(); setTab(tabs[tabs.length - 1]); break;
        }
      });
    });

    setTab(tabs[0]);
  }

  // --- form ------------------------------------------------------------------
  const FORM_FIELDS = [
    'text_top','rim_finish','plate_color','text_colors','state_shape','outline_color',
    'main_symbol','symbol_color','badge_elements','secondary_symbol','aurebesh_style',
    'sabers_desc','style_keywords','flip_arc','lighting_mood','material_finish',
    'detail_level','age_patina'
  ];
  const getDefaultForm = () => ({
    text_top: "GALACTIC JEDI ORDER",
    rim_finish: "polished steel with subtle etching",
    plate_color: "deep obsidian with subtle texture",
    text_colors: "luminous white with shadow outline",
    state_shape: "ornate circular mandala pattern",
    outline_color: "electric blue glow",
    main_symbol: "stylized phoenix rising",
    symbol_color: "gradient gold to crimson",
    badge_elements: "intricate geometric patterns with Celtic knots",
    secondary_symbol: "constellation of stars",
    aurebesh_style: "glowing runic inscriptions around border",
    sabers_desc: "twin energy beams with particle effects",
    style_keywords: "cinematic, photorealistic, dramatic lighting, high detail",
    flip_arc: "auto",
    lighting_mood: "soft",
    material_finish: "polished",
    detail_level: "7",
    age_patina: "2"
  });
  let currentForm = (() => {
    const stored = storage.get(STORAGE_KEYS.FORM);
    if (!stored) return getDefaultForm();
    try { return { ...getDefaultForm(), ...JSON.parse(stored) }; }
    catch { return getDefaultForm(); }
  })();
  const readForm = () => {
    const form = {};
    FORM_FIELDS.forEach(id => { const el = byId(id); if (el) form[id] = el.value.trim(); });
    return form;
  };
  const writeForm = (data) => {
    FORM_FIELDS.forEach(id => { const el = byId(id); if (el && data[id] != null) el.value = data[id]; });
    currentForm = data;
    storage.set(STORAGE_KEYS.FORM, JSON.stringify(currentForm));
  };

  // --- presets ---------------------------------------------------------------
  const getDefaultPresets = () => [
    { id:'jedi_classic', name:'Classic Jedi Order', note:'Traditional design • Blue energy', thumb:'JEDI', form:getDefaultForm() },
    { id:'sith_dark', name:'Dark Side Order', note:'Crimson accents • Gothic styling', thumb:'SITH',
      form:{ ...getDefaultForm(),
        text_top:"SITH ETERNAL", plate_color:"midnight black with red veins",
        text_colors:"blood red with black outline", outline_color:"crimson glow",
        main_symbol:"dark star with spikes", symbol_color:"deep crimson with shadow",
        sabers_desc:"crossed red lightsabers with dark energy" } },
    { id:'mandalorian', name:'Mandalorian Clan', note:'Beskar steel • Warrior heritage', thumb:'MAND',
      form:{ ...getDefaultForm(),
        text_top:"THIS IS THE WAY", rim_finish:"beskar steel with battle worn edges",
        plate_color:"gunmetal gray with scratches", main_symbol:"mythosaur skull",
        symbol_color:"metallic silver with wear marks", badge_elements:"clan sigils and honor marks" } }
  ];
  const getPresets = () => {
    const stored = storage.get(STORAGE_KEYS.PRESETS);
    if (!stored) return getDefaultPresets();
    try {
      const parsed = JSON.parse(stored);
      return Array.isArray(parsed) && parsed.length ? parsed : getDefaultPresets();
    } catch { return getDefaultPresets(); }
  };
  const setPresets = (p) => { storage.set(STORAGE_KEYS.PRESETS, JSON.stringify(p)); renderPresets(); };

  function renderPresets() {
    const wrap = byId('profiles');
    const q = (byId('profileSearch').value || '').toLowerCase();
    wrap.innerHTML = '';
    const list = getPresets().filter(p =>
      !q || p.name.toLowerCase().includes(q) || p.note.toLowerCase().includes(q) || p.thumb.toLowerCase().includes(q)
    );
    list.forEach(preset => {
      const div = document.createElement('div');
      div.className = 'profile slide-in';
      div.innerHTML = `
        <div class="profile-thumb">${preset.thumb}</div>
        <div class="profile-info">
          <div class="name">${preset.name}</div>
          <div class="note">${preset.note}</div>
        </div>
        <div class="profile-actions">
          <button class="chip" data-action="apply" title="Apply this preset">
            <span class="material-icons-round">check</span>
          </button>
          <button class="chip" data-action="delete" title="Delete preset">
            <span class="material-icons-round">delete</span>
          </button>
        </div>`;
      div.querySelector('[data-action="apply"]').addEventListener('click', (e) => {
        e.stopPropagation(); writeForm(preset.form); generatePreview(); showToast(`Applied "${preset.name}"`);
      });
      div.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
        e.stopPropagation();
        const isDefault = getDefaultPresets().some(p => p.id === preset.id);
        if (isDefault) return showToast('Cannot delete default presets','error');
        if (confirm(`Delete "${preset.name}"?`)) { setPresets(getPresets().filter(p => p.id !== preset.id)); showToast('Preset deleted'); }
      });
      div.addEventListener('click', () => { writeForm(preset.form); generatePreview(); showToast(`Loaded "${preset.name}"`); });
      wrap.appendChild(div);
    });
  }

  // --- svg generation --------------------------------------------------------
  function generateSvg(form) {
    const size = parseInt(byId('sizeSelect').value) || 640;
    const R = size / 2;

    const svg = document.createElementNS(NS, 'svg');
    svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
    svg.setAttribute('width', size);
    svg.setAttribute('height', size);
    svg.setAttribute('shape-rendering', 'geometricPrecision');
    svg.setAttribute('text-rendering', 'optimizeLegibility');

    const defs = document.createElementNS(NS, 'defs');
    svg.appendChild(defs);

    const getColor = (input = '', fallback = '#ffffff') => {
      const colors = {
        obsidian:'#0f1419', pearl:'#f8fafc', navy:'#1e293b', crimson:'#991b1b',
        forest:'#166534', purple:'#7c2d12', gold:'#d97706', silver:'#64748b',
        steel:'#475569', bronze:'#92400e', iron:'#374151', copper:'#ea580c', white:'#ffffff', black:'#111827'
      };
      const lower = input.toLowerCase();
      for (const [k, c] of Object.entries(colors)) if (lower.includes(k)) return c;
      return fallback;
    };

    // rim gradient
    const rimGradient = document.createElementNS(NS, 'radialGradient');
    rimGradient.setAttribute('id', 'rimGrad');
    rimGradient.setAttribute('cx', '50%'); rimGradient.setAttribute('cy', '50%'); rimGradient.setAttribute('r', '60%');
    [
      { offset:'0%',   color:'rgba(255,255,255,0.3)' },
      { offset:'40%',  color:getColor(form.rim_finish, '#64748b') },
      { offset:'100%', color:'rgba(0,0,0,0.4)' }
    ].forEach(s => {
      const st = document.createElementNS(NS, 'stop');
      st.setAttribute('offset', s.offset); st.setAttribute('stop-color', s.color); rimGradient.appendChild(st);
    });
    defs.appendChild(rimGradient);

    // base plate + rim stroke
    const plate = document.createElementNS(NS, 'circle');
    plate.setAttribute('cx', R); plate.setAttribute('cy', R);
    plate.setAttribute('r', R * 0.92);
    plate.setAttribute('fill', getColor(form.plate_color, '#0f1419'));
    plate.setAttribute('stroke', 'url(#rimGrad)');
    plate.setAttribute('stroke-width', Math.max(8, size * 0.02));
    svg.appendChild(plate);

    // arced top text
    if (form.text_top.trim()) {
      const sweepRadius = R * 0.75;
      const arcY = R - sweepRadius;
      const useFlipped = form.flip_arc === 'flipped' || (form.flip_arc === 'auto' && (view.rotation % 360) >= 180);
      const pathD = useFlipped
        ? `M ${R + sweepRadius} ${arcY} A ${sweepRadius} ${sweepRadius} 0 0 0 ${R - sweepRadius} ${arcY}`
        : `M ${R - sweepRadius} ${arcY} A ${sweepRadius} ${sweepRadius} 0 0 1 ${R + sweepRadius} ${arcY}`;
      const textPath = document.createElementNS(NS, 'path');
      textPath.setAttribute('id','textArc'); textPath.setAttribute('d', pathD); defs.appendChild(textPath);

      const text = document.createElementNS(NS, 'text');
      text.setAttribute('font-size', Math.max(20, size * 0.04));
      text.setAttribute('font-weight', '800');
      text.setAttribute('fill', getColor(form.text_colors, '#ffffff'));
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('letter-spacing', '1px');

      const tp = document.createElementNS(NS, 'textPath');
      tp.setAttribute('href', '#textArc'); tp.setAttribute('startOffset', '50%');
      tp.textContent = form.text_top.substring(0, 40).toUpperCase();
      text.appendChild(tp);
      svg.appendChild(text);
    }

    // central symbol
    const symbolGroup = document.createElementNS(NS, 'g');
    const symbolSize = R * 0.3;
    if ((form.main_symbol || '').toLowerCase().includes('phoenix')) {
      const phoenix = document.createElementNS(NS, 'path');
      const p = `
        M ${R} ${R - symbolSize * 0.8}
        Q ${R + symbolSize * 0.4} ${R - symbolSize * 0.6} ${R + symbolSize * 0.6} ${R - symbolSize * 0.2}
        Q ${R + symbolSize * 0.8} ${R} ${R + symbolSize * 0.4} ${R + symbolSize * 0.4}
        Q ${R} ${R + symbolSize * 0.6} ${R - symbolSize * 0.4} ${R + symbolSize * 0.4}
        Q ${R - symbolSize * 0.8} ${R} ${R - symbolSize * 0.6} ${R - symbolSize * 0.2}
        Q ${R - symbolSize * 0.4} ${R - symbolSize * 0.6} ${R} ${R - symbolSize * 0.8}`;
      phoenix.setAttribute('d', p);
      phoenix.setAttribute('fill', getColor(form.symbol_color, '#d97706'));
      phoenix.setAttribute('stroke', 'rgba(255,255,255,0.3)');
      phoenix.setAttribute('stroke-width', 2);
      symbolGroup.appendChild(phoenix);
    } else {
      const dot = document.createElementNS(NS, 'circle');
      dot.setAttribute('cx', R); dot.setAttribute('cy', R); dot.setAttribute('r', symbolSize);
      dot.setAttribute('fill', getColor(form.symbol_color, '#6366f1'));
      dot.setAttribute('stroke', getColor(form.outline_color, '#ffffff'));
      dot.setAttribute('stroke-width', 3);
      symbolGroup.appendChild(dot);
    }
    svg.appendChild(symbolGroup);

    // crossed energy beams if requested
    const desc = (form.sabers_desc || '').toLowerCase();
    if (desc.includes('twin') || desc.includes('crossed')) {
      const mk = (x1,y1,x2,y2) => {
        const l = document.createElementNS(NS, 'line');
        l.setAttribute('x1', x1); l.setAttribute('y1', y1);
        l.setAttribute('x2', x2); l.setAttribute('y2', y2);
        l.setAttribute('stroke', '#00bfff'); l.setAttribute('stroke-width', 4);
        l.setAttribute('stroke-linecap', 'round'); l.setAttribute('opacity', '0.85');
        return l;
      };
      svg.appendChild(mk(R - R*0.3, R - R*0.3, R + R*0.3, R + R*0.3));
      svg.appendChild(mk(R + R*0.3, R - R*0.3, R - R*0.3, R + R*0.3));
    }

    return svg;
  }

  // --- view state ------------------------------------------------------------
  let view = { x:0, y:0, scale:1, rotation:0, minScale:0.1, maxScale:5, width:640, height:640 };
  function loadViewState(){ try{ const s = storage.get(STORAGE_KEYS.VIEW); if (s) view = { ...view, ...JSON.parse(s) }; } catch {} }
  function saveViewState(){ storage.set(STORAGE_KEYS.VIEW, JSON.stringify(view)); }
  function updatePreview() {
    const stage = byId('stage'); const inner = byId('inner'); const r = stage.getBoundingClientRect();
    inner.style.transform =
      `translate(${r.width/2 + view.x}px, ${r.height/2 + view.y}px)
       rotate(${view.rotation}deg)
       scale(${view.scale})
       translate(${-view.width/2}px, ${-view.height/2}px)`;
    byId('hudZoom').textContent = `${Math.round(view.scale * 100)}%`;
    byId('hudSize').textContent = `${Math.round(r.width)}×${Math.round(r.height)}px`;
    saveViewState();
  }

  // --- preview & prompt ------------------------------------------------------
  function generatePreview() {
    const form = readForm();
    const svg = generateSvg(form);
    svg.querySelectorAll('path, circle, line, polygon').forEach(el => {
      if (!el.hasAttribute('vector-effect')) el.setAttribute('vector-effect', 'non-scaling-stroke');
    });
    const inner = byId('inner'); inner.innerHTML = ''; inner.appendChild(svg);
    updatePreview(); generatePrompt();
    byId('live').textContent = 'Preview updated';
  }
  function generatePrompt() {
    const f = readForm();
    const detail = +f.detail_level || 7, age = +f.age_patina || 2;
    const detailTerms = detail > 7 ? 'highly detailed, intricate craftsmanship'
                      : detail > 4 ? 'moderate detail, quality craftsmanship'
                      : 'clean, minimalist design';
    const ageTerms = age > 7 ? 'ancient, heavily weathered, archaeological artifact'
                    : age > 4 ? 'aged, battle-worn, historical piece'
                    : 'pristine, newly forged';
    const txt = `
Professional medallion design render, ${f.style_keywords}.

STRUCTURE & MATERIALS:
• Base: Circular pendant, ${f.rim_finish} rim with ${f.plate_color} central plate
• Surface: ${f.material_finish} finish, ${ageTerms}
• Text: Raised inscription "${f.text_top}" in ${f.text_colors}
• Border: ${f.outline_color} accent lighting

CENTRAL DESIGN:
• Primary: ${f.state_shape} featuring ${f.main_symbol} (${f.symbol_color})
• Details: ${f.badge_elements}
• Secondary: ${f.secondary_symbol}
• Script: ${f.aurebesh_style}

EFFECTS & LIGHTING:
• Energy: ${f.sabers_desc}
• Mood: ${f.lighting_mood} lighting with ${detailTerms}
• Quality: Photorealistic rendering, studio lighting, premium materials

Technical: 4K resolution, physically accurate materials, professional product photography style.`.trim();
    byId('out').value = txt;
  }

  // --- interactions ----------------------------------------------------------
  function initInteractions() {
    const stage = byId('stage');
    let pointers = new Map(), lastCenter = null, lastDist = null;

    stage.addEventListener('pointerdown', e => { stage.setPointerCapture?.(e.pointerId); pointers.set(e.pointerId, {x:e.clientX,y:e.clientY}); });
    ['pointerup','pointercancel'].forEach(ev => stage.addEventListener(ev, e => {
      stage.releasePointerCapture?.(e.pointerId); pointers.delete(e.pointerId);
      if (pointers.size === 0) { lastCenter = lastDist = null; }
    }));
    stage.addEventListener('pointermove', e => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
      const pts = [...pointers.values()];
      if (pts.length === 1) {
        const p = pts[0];
        if (lastCenter) { view.x += p.x - lastCenter.x; view.y += p.y - lastCenter.y; updatePreview(); }
        lastCenter = {...p};
      } else if (pts.length === 2) {
        const c = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
        const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
        if (lastCenter && lastDist) {
          view.x += c.x - lastCenter.x; view.y += c.y - lastCenter.y;
          const newScale = clamp(view.scale * (d/lastDist), view.minScale, view.maxScale);
          const rect = stage.getBoundingClientRect();
          const zx = c.x - rect.left - rect.width/2 - view.x;
          const zy = c.y - rect.top  - rect.height/2 - view.y;
          const ratio = newScale / view.scale;
          view.x -= zx * (ratio - 1); view.y -= zy * (ratio - 1); view.scale = newScale;
          updatePreview();
        }
        lastCenter = c; lastDist = d;
      }
    });
    stage.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -e.deltaY * (e.ctrlKey || e.metaKey ? 0.003 : 0.002);
      const newScale = clamp(view.scale * (1 + delta), view.minScale, view.maxScale);
      const rect = stage.getBoundingClientRect();
      const zx = e.clientX - rect.left - rect.width/2 - view.x;
      const zy = e.clientY - rect.top  - rect.height/2 - view.y;
      const ratio = newScale / view.scale;
      view.x -= zx * (ratio - 1); view.y -= zy * (ratio - 1); view.scale = newScale;
      updatePreview();
    }, { passive:false });

    stage.addEventListener('dblclick', fitToView);
    byId('fit').addEventListener('click', fitToView);
    byId('fillView').addEventListener('click', fillToView);
    byId('resetView').addEventListener('click', resetView);
    byId('rotateView').addEventListener('click', rotateView);

    byId('sizeSelect').addEventListener('change', e => {
      const n = parseInt(e.target.value) || 640;
      view.width = view.height = n;
      generatePreview();
      setTimeout(fitToView, 50);
    });
  }
  function fitToView() {
    const rect = byId('stage').getBoundingClientRect(), m = 40;
    view.scale = Math.min((rect.width - m) / view.width, (rect.height - m) / view.height);
    view.x = view.y = 0; updatePreview(); showToast('Fitted to view');
  }
  function fillToView() {
    const rect = byId('stage').getBoundingClientRect();
    view.scale = Math.max(rect.width / view.width, rect.height / view.height);
    view.x = view.y = 0; updatePreview(); showToast('Filled viewport');
  }
  function resetView(){ view.x=0; view.y=0; view.scale=1; view.rotation=0; updatePreview(); showToast('View reset'); }
  function rotateView(){ view.rotation=(view.rotation+45)%360; updatePreview(); showToast(`Rotated to ${view.rotation}°`); }

  // --- swatches --------------------------------------------------------------
  function initSwatches() {
    [{containerId:'rim_swatches',inputId:'rim_finish'},{containerId:'plate_swatches',inputId:'plate_color'}]
    .forEach(({containerId,inputId}) => {
      const wrap = byId(containerId), input = byId(inputId);
      if (!wrap || !input) return;
      wrap.addEventListener('click', e => {
        const sw = e.target.closest('.swatch'); if (!sw) return;
        wrap.querySelectorAll('.swatch').forEach(s => s.setAttribute('aria-pressed','false'));
        sw.setAttribute('aria-pressed','true');
        input.value = sw.dataset.val || '';
        debouncedGenerate();
        showToast(`Applied ${sw.textContent} preset`);
      });
    });
  }

  // --- exports ---------------------------------------------------------------
  function initExports() {
    byId('copyBtn').addEventListener('click', async () => {
      const t = byId('out').value; if (!t.trim()) return showToast('No content to copy','error');
      try { await navigator.clipboard.writeText(t); showToast('Prompt copied to clipboard'); }
      catch { showToast('Copy failed','error'); }
    });
    byId('downloadBtn').addEventListener('click', () => {
      const t = byId('out').value; if (!t.trim()) return showToast('No content to download','error');
      const blob = new Blob([t], {type:'text/plain'}), url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=`medallion_prompt_${Date.now()}.txt`; a.click(); URL.revokeObjectURL(url);
      showToast('Prompt downloaded');
    });

    const getSvgXml = () => {
      const svg = byId('inner').querySelector('svg'); if (!svg) return null;
      const clone = svg.cloneNode(true), wrap = document.createElementNS(NS,'g');
      while (clone.firstChild) wrap.appendChild(clone.firstChild);
      if (view.rotation) wrap.setAttribute('transform', `rotate(${view.rotation} ${view.width/2} ${view.height/2})`);
      clone.appendChild(wrap); clone.setAttribute('xmlns', NS);
      return `<?xml version="1.0" encoding="UTF-8"?>\n${clone.outerHTML}`;
    };

    byId('copySvgBtn').addEventListener('click', async () => {
      const xml = getSvgXml(); if (!xml) return showToast('No SVG to copy','error');
      try { await navigator.clipboard.writeText(xml); showToast('SVG copied to clipboard'); }
      catch { showToast('SVG copy failed','error'); }
    });
    byId('downloadSvgBtn').addEventListener('click', () => {
      const xml = getSvgXml(); if (!xml) return showToast('No SVG to export','error');
      const blob = new Blob([xml], {type:'image/svg+xml'}), url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=`medallion_${view.width}x${view.height}.svg`; a.click(); URL.revokeObjectURL(url);
      showToast('SVG downloaded');
    });
    byId('downloadPngBtn').addEventListener('click', () => {
      const xml = getSvgXml(); if (!xml) return showToast('No image to export','error');
      const blob = new Blob([xml], {type:'image/svg+xml'}), url = URL.createObjectURL(blob), img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas'), scale = 2;
        canvas.width = view.width * scale; canvas.height = view.height * scale;
        const ctx = canvas.getContext('2d'); ctx.scale(scale, scale); ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        canvas.toBlob(b => {
          if (!b) return showToast('PNG export failed','error');
          const u = URL.createObjectURL(b), a = document.createElement('a');
          a.href=u; a.download=`medallion_${view.width}x${view.height}_${Date.now()}.png`; a.click(); URL.revokeObjectURL(u);
          showToast('PNG exported successfully');
        }, 'image/png', 0.95);
      };
      img.onerror = () => { URL.revokeObjectURL(url); showToast('PNG export failed','error'); };
      img.crossOrigin = 'anonymous'; img.src = url;
    });
  }

  // --- preset actions --------------------------------------------------------
  function initPresetActions() {
    byId('addPresetBtn').addEventListener('click', () => {
      const form = readForm(); const name = form.text_top.trim() || 'Custom Preset';
      const short = name.split(' ').slice(0,3).join(' ').substring(0,25);
      const preset = {
        id:`user_${Date.now()}_${Math.random().toString(36).slice(2,11)}`,
        name:short, note:'Custom design • User created',
        thumb:(short.split(' ').map(w=>w[0]).join('') || 'CUST').toUpperCase().slice(0,4),
        form:{...form}
      };
      const list = getPresets(); list.push(preset); setPresets(list); showToast(`Saved "${short}"`);
    });
    byId('randBtn').addEventListener('click', () => {
      const pick = a => a[Math.floor(Math.random()*a.length)];
      const rf = {
        ...getDefaultForm(),
        text_top: pick(['COSMIC GUARDIAN','STELLAR KNIGHT','VOID WALKER','STAR FORGE','GALAXY DEFENDER']),
        rim_finish: pick(['polished steel','brushed silver','antique gold','weathered bronze','blackened iron']),
        plate_color: pick(['deep obsidian','midnight navy','crimson red','forest green','royal purple']),
        main_symbol: pick(['stylized phoenix','cosmic spiral','star constellation','dragon insignia','celestial crown']),
        symbol_color: pick(['gradient gold to crimson','electric blue glow','silver with shadows','prismatic rainbow','deep emerald']),
        flip_arc: pick(['auto','normal','flipped']),
        lighting_mood: pick(['dramatic','soft','ethereal','moody'])
      };
      writeForm(rf); generatePreview(); showToast('Random configuration generated');
    });
  }

  // --- JSON modal ------------------------------------------------------------
  function initJsonModal() {
    const modal = byId('jsonModal'), textarea = byId('jsonArea');
    byId('exportJsonBtn').addEventListener('click', () => {
      textarea.value = JSON.stringify({ version:'2.0', timestamp:new Date().toISOString(), form:readForm(), presets:getPresets(), view }, null, 2);
      modal.showModal(); showToast('Export data prepared');
    });
    byId('importJsonBtn').addEventListener('click', () => { textarea.value=''; textarea.placeholder='Paste your configuration JSON here...'; modal.showModal(); });
    byId('validateJson').addEventListener('click', () => {
      try {
        const d = JSON.parse(textarea.value || '{}'); showToast('JSON is valid','success');
        const info = []; if (d.form) info.push('Form configuration'); if (d.presets) info.push(`${d.presets.length} presets`); if (d.view) info.push('View settings');
        if (info.length) showToast(`Will import: ${info.join(', ')}`,'info');
      } catch (e) { showToast(`Invalid JSON: ${e.message}`,'error'); }
    });
    byId('applyJson').addEventListener('click', () => {
      try {
        const d = JSON.parse(textarea.value || '{}');
        if (d.form) writeForm({ ...getDefaultForm(), ...d.form });
        if (Array.isArray(d.presets)) setPresets(d.presets);
        if (d.view) view = { ...view, ...d.view };
        generatePreview(); renderPresets(); modal.close(); showToast('Configuration imported successfully');
      } catch (e) { showToast(`Import failed: ${e.message}`,'error'); }
    });
    byId('copyJson').addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(textarea.value); showToast('JSON copied to clipboard'); }
      catch { showToast('Copy failed','error'); }
    });
    byId('closeJson').addEventListener('click', () => modal.close());
  }

  // --- fullscreen ------------------------------------------------------------
  function initFullscreen() {
    const modal = byId('fullscreenModal'), inner = byId('fullscreenInner');
    byId('fullscreenBtn').addEventListener('click', () => {
      const cur = byId('inner').querySelector('svg'); if (!cur) return showToast('No preview to show','error');
      const clone = cur.cloneNode(true); inner.innerHTML=''; inner.appendChild(clone);
      const stageSize = 600, scale = Math.min(stageSize / view.width, stageSize / view.height) * 0.9;
      inner.style.transform = `translate(${stageSize/2}px, ${stageSize/2}px) scale(${scale}) translate(${-view.width/2}px, ${-view.height/2}px)`;
      modal.showModal();
    });
    byId('closeFullscreen').addEventListener('click', () => modal.close());
  }

  // --- animation -------------------------------------------------------------
  let animationId = null, animating = false;
  function initAnimation() {
    byId('animateBtn').addEventListener('click', () => { animating ? stopAnimation() : startAnimation(); });
  }
  function startAnimation() {
    if (animating) return; animating = true;
    const btn = byId('animateBtn'); btn.querySelector('.material-icons-round').textContent = 'pause_circle'; btn.title = 'Stop animation';
    let start = Date.now();
    const loop = () => {
      if (!animating) return;
      const t = (Date.now() - start) / 1000;
      view.rotation = (t * 30) % 360; updatePreview();
      animationId = requestAnimationFrame(loop);
    };
    loop(); showToast('Animation started');
  }
  function stopAnimation() {
    animating = false; if (animationId) cancelAnimationFrame(animationId), animationId = null;
    const btn = byId('animateBtn'); btn.querySelector('.material-icons-round').textContent = 'play_circle'; btn.title = 'Start animation';
    showToast('Animation stopped');
  }

  // --- reactivity ------------------------------------------------------------
  const debouncedGenerate = (() => { let t; return (d=300) => { clearTimeout(t); t = setTimeout(() => generatePreview(), d); }; })();
  function initFormReactivity() {
    FORM_FIELDS.forEach(id => {
      const el = byId(id); if (!el) return;
      const evts = el.type === 'range' ? ['input'] : ['input','change'];
      evts.forEach(e => el.addEventListener(e, () => debouncedGenerate(el.type === 'range' ? 100 : 300)));
    });
    byId('clearBtn').addEventListener('click', () => {
      if (confirm('Reset all settings to defaults?')) { writeForm(getDefaultForm()); generatePreview(); showToast('Settings reset to defaults'); }
    });
    byId('gen').addEventListener('click', () => { generatePreview(); showToast('Preview regenerated'); });
  }

  // --- keyboard shortcuts (querySelector for singles) ------------------------
  function initKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey)) {
        switch (e.key.toLowerCase()) {
          case 'enter': e.preventDefault(); generatePreview(); showToast('Generated via shortcut'); break;
          case 'r': if (e.shiftKey){ e.preventDefault(); resetView(); } break;
          case 's': if (e.shiftKey){ e.preventDefault(); byId('addPresetBtn').click(); } break;
          case 'f': e.preventDefault(); fitToView(); break;
        }
      }
      if (e.key === 'Tab') {
        const activeTab = document.querySelector('.tab[aria-selected="true"]');
        if (activeTab && document.activeElement === activeTab) {
          const activePanel = document.querySelector('.tabpanel:not([hidden])');
          const firstInput = activePanel?.querySelector('input, select, textarea');
          if (firstInput) { e.preventDefault(); firstInput.focus(); }
        }
      }
    });
  }

  // --- responsive ------------------------------------------------------------
  function initResponsive() {
    const ro = new ResizeObserver(entries => { for (const ent of entries) if (ent.target.id === 'stage') updatePreview(); });
    ro.observe(byId('stage'));
  }

  // --- search ----------------------------------------------------------------
  function initSearch() {
    const input = byId('profileSearch');
    input.addEventListener('input', () => { clearTimeout(input.searchTimeout); input.searchTimeout = setTimeout(renderPresets, 200); });
    input.addEventListener('keydown', e => { if (e.key === 'Escape'){ input.value=''; renderPresets(); input.blur(); } });
  }

  // --- boot ------------------------------------------------------------------
  function init() {
    try {
      loadViewState();
      initTheme();
      initTabs();
      initSwatches();
      initInteractions();
      initExports();
      initPresetActions();
      initJsonModal();
      initFullscreen();
      initAnimation();
      initFormReactivity();
      initKeyboardShortcuts();
      initResponsive();
      initSearch();

      writeForm(currentForm);
      renderPresets();

      const sizeSelect = byId('sizeSelect');
      view.width = view.height = parseInt(sizeSelect.value) || 640;

      setTimeout(() => {
        generatePreview();
        fitToView();
        showToast('Medallion Forge Enhanced ready');
      }, 100);
    } catch (err) {
      console.error('Initialization error:', err);
      showToast('Initialization error - check console', 'error');
    }
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
})();
</script>