<script>
/* ===== Medallion Forge — Enhanced Edition (fixed helpers + Eruda bootstrap) ===== */
(() => {
  'use strict';

  // --- helpers (fixed) -------------------------------------------------------
  const $  = s => document.querySelector(s);                 // single
  const $$ = s => Array.from(document.querySelectorAll(s));  // many
  const byId = id => document.getElementById(id);
  const NS = 'http://www.w3.org/2000/svg';
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // Quietly init Eruda if it's present (prevents console spam)
  if (window.eruda && typeof window.eruda.init === 'function') {
    try { window.eruda.init(); } catch { /* no-op */ }
  }

  // --- storage ---------------------------------------------------------------
  const STORAGE_KEYS = {
    FORM: 'medallion:enhanced:form',
    PRESETS: 'medallion:enhanced:presets',
    THEME: 'medallion:enhanced:theme',
    VIEW: 'medallion:enhanced:view'
  };
  const storage = {
    get: k => { try { return localStorage.getItem(k) } catch { return null } },
    set: (k, v) => { try { localStorage.setItem(k, v) } catch {} },
    del: k => { try { localStorage.removeItem(k) } catch {} }
  };

  // --- toast -----------------------------------------------------------------
  const toastContainer = byId('toastContainer');
  let toastId = 0;
  const showToast = (message, type = 'success', duration = 3000) => {
    const el = document.createElement('div');
    el.className = `toast ${type} show`;
    el.id = `toast-${++toastId}`;
    el.innerHTML = `
      <div style="display:flex;align-items:center;gap:10px">
        <span class="material-icons-round">
          ${type === 'success' ? 'check_circle' : type === 'error' ? 'error' : 'info'}
        </span>
        <span>${message}</span>
      </div>`;
    toastContainer.appendChild(el);
    byId('live').textContent = message;
    setTimeout(() => {
      el.style.opacity = '0';
      el.style.transform = 'translateX(100%) scale(0.95)';
      setTimeout(() => el.remove(), 200);
    }, duration);
  };

  // --- theme -----------------------------------------------------------------
  function initTheme() {
    const stored = storage.get(STORAGE_KEYS.THEME);
    if (stored === 'light') document.body.classList.add('theme-light');

    const updateTheme = () => {
      const isLight = document.body.classList.contains('theme-light');
      const toggle = byId('themeToggle');
      const icon = toggle.querySelector('.material-icons-round');
      const label = byId('themeLabel');
      toggle.setAttribute('aria-pressed', String(isLight));
      icon.textContent = isLight ? 'light_mode' : 'dark_mode';
      label.textContent = isLight ? 'Light' : 'Dark';
      byId('stage').classList.toggle('light', isLight);
    };

    updateTheme();
    byId('themeToggle').addEventListener('click', () => {
      const isLight = document.body.classList.toggle('theme-light');
      storage.set(STORAGE_KEYS.THEME, isLight ? 'light' : 'dark');
      updateTheme();
      showToast(`Switched to ${isLight ? 'Light' : 'Dark'} theme`);
    });
  }

  // --- tabs (uses $$) --------------------------------------------------------
  function initTabs() {
    const tabs = $$('.tab');
    const panels = {
      basic: byId('panel-basic'),
      symbols: byId('panel-symbols'),
      advanced: byId('panel-advanced'),
      export: byId('panel-export')
    };

    const setTab = (activeTab) => {
      const targetId = activeTab.dataset.tab;
      tabs.forEach(tab => {
        const on = tab === activeTab;
        tab.setAttribute('aria-selected', String(on));
        tab.tabIndex = on ? 0 : -1;
      });
      Object.entries(panels).forEach(([id, panel]) => { panel.hidden = id !== targetId; });
      activeTab.focus();
    };

    tabs.forEach((tab, index) => {
      tab.addEventListener('click', () => setTab(tab));
      tab.addEventListener('keydown', e => {
        switch (e.key) {
          case 'ArrowRight': e.preventDefault(); setTab(tabs[(index + 1) % tabs.length]); break;
          case 'ArrowLeft':  e.preventDefault(); setTab(tabs[(index - 1 + tabs.length) % tabs.length]); break;
          case 'Home':       e.preventDefault(); setTab(tabs[0]); break;
          case 'End':        e.preventDefault(); setTab(tabs[tabs.length - 1]); break;
        }
      });
    });

    setTab(tabs[0]);
  }

  // --- form ------------------------------------------------------------------
  const FORM_FIELDS = [
    'text_top','rim_finish','plate_color','text_colors','state_shape','outline_color',
    'main_symbol','symbol_color','badge_elements','secondary_symbol','aurebesh_style',
    'sabers_desc','style_keywords','flip_arc','lighting_mood','material_finish',
    'detail_level','age_patina'
  ];
  const getDefaultForm = () => ({
    text_top: "GALACTIC JEDI ORDER",
    rim_finish: "polished steel with subtle etching",
    plate_color: "deep obsidian with subtle texture",
    text_colors: "luminous white with shadow outline",
    state_shape: "ornate circular mandala pattern",
    outline_color: "electric blue glow",
    main_symbol: "stylized phoenix rising",
    symbol_color: "gradient gold to crimson",
    badge_elements: "intricate geometric patterns with Celtic knots",
    secondary_symbol: "constellation of stars",
    aurebesh_style: "glowing runic inscriptions around border",
    sabers_desc: "twin energy beams with particle effects",
    style_keywords: "cinematic, photorealistic, dramatic lighting, high detail",
    flip_arc: "auto",
    lighting_mood: "soft",
    material_finish: "polished",
    detail_level: "7",
    age_patina: "2"
  });
  let currentForm = (() => {
    const stored = storage.get(STORAGE_KEYS.FORM);
    if (!stored) return getDefaultForm();
    try { return { ...getDefaultForm(), ...JSON.parse(stored) }; }
    catch { return getDefaultForm(); }
  })();
  const readForm = () => {
    const form = {};
    FORM_FIELDS.forEach(id => { const el = byId(id); if (el) form[id] = el.value.trim(); });
    return form;
  };
  const writeForm = (data) => {
    FORM_FIELDS.forEach(id => { const el = byId(id); if (el && data[id] != null) el.value = data[id]; });
    currentForm = data;
    storage.set(STORAGE_KEYS.FORM, JSON.stringify(currentForm));
  };

  // --- presets ---------------------------------------------------------------
  const getDefaultPresets = () => [
    { id:'jedi_classic', name:'Classic Jedi Order', note:'Traditional design • Blue energy', thumb:'JEDI', form:getDefaultForm() },
    { id:'sith_dark', name:'Dark Side Order', note:'Crimson accents • Gothic styling', thumb:'SITH',
      form:{ ...getDefaultForm(),
        text_top:"SITH ETERNAL", plate_color:"midnight black with red veins",
        text_colors:"blood red with black outline", outline_color:"crimson glow",
        main_symbol:"dark star with spikes", symbol_color:"deep crimson with shadow",
        sabers_desc:"crossed red lightsabers with dark energy" } },
    { id:'mandalorian', name:'Mandalorian Clan', note:'Beskar steel • Warrior heritage', thumb:'MAND',
      form:{ ...getDefaultForm(),
        text_top:"THIS IS THE WAY", rim_finish:"beskar steel with battle worn edges",
        plate_color:"gunmetal gray with scratches", main_symbol:"mythosaur skull",
        symbol_color:"metallic silver with wear marks", badge_elements:"clan sigils and honor marks" } }
  ];
  const getPresets = () => {
    const stored = storage.get(STORAGE_KEYS.PRESETS);
    if (!stored) return getDefaultPresets();
    try {
      const parsed = JSON.parse(stored);
      return Array.isArray(parsed) && parsed.length ? parsed : getDefaultPresets();
    } catch { return getDefaultPresets(); }
  };
  const setPresets = (p) => { storage.set(STORAGE_KEYS.PRESETS, JSON.stringify(p)); renderPresets(); };

  function renderPresets() {
    const wrap = byId('profiles');
    const q = (byId('profileSearch').value || '').toLowerCase();
    wrap.innerHTML = '';
    const list = getPresets().filter(p =>
      !q || p.name.toLowerCase().includes(q) || p.note.toLowerCase().includes(q) || p.thumb.toLowerCase().includes(q)
    );
    list.forEach(preset => {
      const div = document.createElement('div');
      div.className = 'profile slide-in';
      div.innerHTML = `
        <div class="profile-thumb">${preset.thumb}</div>
        <div class="profile-info">
          <div class="name">${preset.name}</div>
          <div class="note">${preset.note}</div>
        </div>
        <div class="profile-actions">
          <button class="chip" data-action="apply" title="Apply this preset">
            <span class="material-icons-round">check</span>
          </button>
          <button class="chip" data-action="delete" title="Delete preset">
            <span class="material-icons-round">delete</span>
          </button>
        </div>`;
      div.querySelector('[data-action="apply"]').addEventListener('click', (e) => {
        e.stopPropagation(); writeForm(preset.form); generatePreview(); showToast(`Applied "${preset.name}"`);
      });
      div.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
        e.stopPropagation();
        const isDefault = getDefaultPresets().some(p => p.id === preset.id);
        if (isDefault) return showToast('Cannot delete default presets','error');
        if (confirm(`Delete "${preset.name}"?`)) { setPresets(getPresets().filter(p => p.id !== preset.id)); showToast('Preset deleted'); }
      });
      div.addEventListener('click', () => { writeForm(preset.form); generatePreview(); showToast(`Loaded "${preset.name}"`); });
      wrap.appendChild(div);
    });
  }

  // --- svg generation --------------------------------------------------------
  // --- DROP-IN REPLACEMENT ---
function generateSvg(form) {
  const size = parseInt(byId('sizeSelect').value) || 640;
  const R = size / 2;

  const svg = document.createElementNS(NS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
  svg.setAttribute('width', size);
  svg.setAttribute('height', size);
  svg.setAttribute('shape-rendering', 'geometricPrecision');
  svg.setAttribute('text-rendering', 'optimizeLegibility');

  // ----- defs: gradients & filters -----------------------------------------
  const defs = document.createElementNS(NS, 'defs');
  svg.appendChild(defs);

  const getColor = (input = '', fallback = '#ffffff') => {
    const colors = {
      obsidian:'#0f1419', black:'#111827', white:'#ffffff', pearl:'#f8fafc',
      navy:'#1e293b', midnight:'#0b2346', crimson:'#991b1b', red:'#ef4444',
      forest:'#166534', emerald:'#10b981', gold:'#d6a446', bronze:'#8d5a2b',
      copper:'#c46b3c', silver:'#bfc7d5', steel:'#6b7280', iron:'#374151',
      purple:'#6b21a8', blue:'#3b82f6'
    };
    const s = input.toLowerCase();
    for (const [k, v] of Object.entries(colors)) if (s.includes(k)) return v;
    return fallback;
  };

  // Rim metal gradient (gives bevel)
  const rimGrad = document.createElementNS(NS, 'radialGradient');
  rimGrad.setAttribute('id', 'rimGrad');
  rimGrad.setAttribute('cx', '50%');
  rimGrad.setAttribute('cy', '40%');
  rimGrad.setAttribute('r', '65%');
  [
    ['0%','rgba(255,255,255,0.9)'],
    ['25%', getColor(form.rim_finish, '#bfc7d5')],
    ['55%','rgba(0,0,0,0.35)'],
    ['100%', getColor(form.rim_finish, '#9aa3b2')]
  ].forEach(([offset, color])=>{
    const s = document.createElementNS(NS,'stop');
    s.setAttribute('offset',offset); s.setAttribute('stop-color',color); rimGrad.appendChild(s);
  });
  defs.appendChild(rimGrad);

  // Plate gradient (subtle vignette)
  const plateGrad = document.createElementNS(NS, 'radialGradient');
  plateGrad.setAttribute('id', 'plateGrad');
  plateGrad.setAttribute('cx', '50%');
  plateGrad.setAttribute('cy', '50%');
  plateGrad.setAttribute('r', '80%');
  [
    ['0%', getColor(form.plate_color, '#0f1419')],
    ['100%', 'rgba(0,0,0,0.4)']
  ].forEach(([offset, color])=>{
    const s = document.createElementNS(NS,'stop');
    s.setAttribute('offset',offset); s.setAttribute('stop-color',color); plateGrad.appendChild(s);
  });
  defs.appendChild(plateGrad);

  // Glow filter for energy beams / highlights
  const glow = document.createElementNS(NS, 'filter');
  glow.setAttribute('id','glow');
  glow.setAttribute('x','-40%'); glow.setAttribute('y','-40%');
  glow.setAttribute('width','180%'); glow.setAttribute('height','180%');
  glow.innerHTML = `
    <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur1"/>
    <feGaussianBlur in="SourceGraphic" stdDeviation="6" result="blur2"/>
    <feMerge>
      <feMergeNode in="blur2"/>
      <feMergeNode in="blur1"/>
      <feMergeNode in="SourceGraphic"/>
    </feMerge>
  `;
  defs.appendChild(glow);

  // Stroke gradient for beams
  const beamGrad = document.createElementNS(NS, 'linearGradient');
  beamGrad.setAttribute('id','beam');
  beamGrad.setAttribute('x1','0%'); beamGrad.setAttribute('y1','0%');
  beamGrad.setAttribute('x2','100%'); beamGrad.setAttribute('y2','100%');
  [
    ['0%','#baf1ff'],
    ['50%','#6ee7ff'],
    ['100%','#2dd4bf']
  ].forEach(([offset,color])=>{
    const s = document.createElementNS(NS,'stop');
    s.setAttribute('offset',offset); s.setAttribute('stop-color',color); beamGrad.appendChild(s);
  });
  defs.appendChild(beamGrad);

  // ----- badge geometry -----------------------------------------------------
  const g = (name, attrs={}, parent=svg) => {
    const el = document.createElementNS(NS,name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k,String(v));
    parent.appendChild(el);
    return el;
  };

  // Bail loop (top ring)
  const bailOuterR = R * 0.13;
  const bail = g('circle', {
    cx: R, cy: R * 0.12 + bailOuterR, r: bailOuterR,
    fill: 'url(#rimGrad)', stroke: 'rgba(0,0,0,0.35)', 'stroke-width': size*0.01
  });
  g('circle', {
    cx: R, cy: R * 0.12 + bailOuterR, r: bailOuterR * 0.55,
    fill: getColor(form.plate_color, '#0f1419')
  });

  // Outer rim (bevelled)
  const rim = g('circle', {
    cx:R, cy:R, r:R*0.95, fill:'url(#rimGrad)'
  });

  // Inner cut to create a ring
  g('circle', {
    cx:R, cy:R, r:R*0.85, fill:'url(#plateGrad)'
  });

  // Tiny inner inset ring for detail
  g('circle', {
    cx:R, cy:R, r:R*0.62, fill:'none',
    stroke:getColor(form.outline_color,'#cbd5e1'),
    'stroke-width': Math.max(2, size*0.006), 'opacity':'0.7'
  });

  // ----- Top + bottom arced text -------------------------------------------
  const addArcText = (text, radius, side='top') => {
    if (!text || !text.trim()) return;
    const id = `arc-${side}`;
    const arc = g('path', { id, d:'' }, defs);
    const sweepR = radius;
    const y = side === 'top' ? R - sweepR : R + sweepR;
    const pathD = side === 'top'
      ? `M ${R - sweepR} ${y} A ${sweepR} ${sweepR} 0 0 1 ${R + sweepR} ${y}`
      : `M ${R + sweepR} ${y} A ${sweepR} ${sweepR} 0 0 1 ${R - sweepR} ${y}`;
    arc.setAttribute('d', pathD);

    const t = g('text', {
      'font-size': Math.max(18, size * 0.05),
      'font-weight':'800',
      'font-family':'Inter,system-ui,sans-serif',
      fill: getColor(form.text_colors, '#ffffff'),
      'letter-spacing':'1.2px'
    });
    const tp = g('textPath', { href:`#${id}`, startOffset:'50%' }, t);
    tp.textContent = text.substring(0, 36).toUpperCase();
    if (side === 'bottom') t.setAttribute('dominant-baseline','hanging');
    svg.appendChild(t);
  };

  // Top text (your field) + optional bottom from badge_elements (fallback)
  addArcText(form.text_top,        R * 0.72, 'top');
  addArcText(form.secondary_symbol || '', R * 0.72, 'bottom');

  // ----- Central emblem -----------------------------------------------------
  const emblem = g('g', {});

  // If user asked for a phoenix, draw stylized mark; else a crisp medallion glyph.
  const hasPhoenix = (form.main_symbol || '').toLowerCase().includes('phoenix');
  if (hasPhoenix) {
    const S = R * 0.30;
    const p = g('path', {
      d: `
        M ${R} ${R - S*0.9}
        Q ${R + S*0.45} ${R - S*0.65} ${R + S*0.7} ${R - S*0.15}
        Q ${R + S*0.9} ${R + S*0.15} ${R + S*0.45} ${R + S*0.5}
        Q ${R} ${R + S*0.75} ${R - S*0.45} ${R + S*0.5}
        Q ${R - S*0.9} ${R + S*0.15} ${R - S*0.7} ${R - S*0.15}
        Q ${R - S*0.45} ${R - S*0.65} ${R} ${R - S*0.9}
      `,
      fill: getColor(form.symbol_color, '#d6a446'),
      stroke: 'rgba(255,255,255,0.35)', 'stroke-width': Math.max(1.5, size*0.003)
    }, emblem);
    // Eye highlight
    g('circle', { cx:R, cy:R - S*0.45, r:Math.max(1.2, size*0.004), fill:'#fff', opacity:'0.85' }, emblem);
  } else if ((form.main_symbol || '').toLowerCase().includes('death') ||
             (form.main_symbol || '').toLowerCase().includes('star')) {
    // Simple "Death Star" motif with dish
    const S = R * 0.26;
    g('circle', {
      cx:R, cy:R, r:S, fill:getColor(form.symbol_color, '#6b7280'),
      stroke:getColor(form.outline_color, '#e5e7eb'), 'stroke-width': Math.max(2, size*0.005)
    }, emblem);
    // Equator line
    g('line', {
      x1:R - S*0.95, y1:R - S*0.05, x2:R + S*0.95, y2:R - S*0.05,
      stroke:'rgba(255,255,255,0.45)', 'stroke-width': Math.max(1, size*0.003)
    }, emblem);
    // Dish
    g('circle', { cx:R + S*0.35, cy:R - S*0.25, r:S*0.28, fill:'rgba(255,255,255,0.15)' }, emblem);
    g('circle', { cx:R + S*0.35, cy:R - S*0.25, r:S*0.12, fill:'rgba(255,255,255,0.35)' }, emblem);
  } else {
    // Default sigil: concentric crest + star
    const S = R * 0.27;
    g('circle', {
      cx:R, cy:R, r:S, fill:getColor(form.symbol_color, '#3b82f6'),
      stroke:getColor(form.outline_color, '#e5e7eb'), 'stroke-width': Math.max(2, size*0.005)
    }, emblem);
    g('circle', { cx:R, cy:R, r:S*0.68, fill:'none', stroke:'rgba(255,255,255,0.35)', 'stroke-width': Math.max(1, size*0.003) }, emblem);
    // 5-point star
    const k = (i) => {
      const outer = S*0.58, inner = S*0.24;
      const a = -90 + i*72;
      const ao = (a * Math.PI)/180, ai = ((a+36) * Math.PI)/180;
      return [
        R + outer*Math.cos(ao), R + outer*Math.sin(ao),
        R + inner*Math.cos(ai), R + inner*Math.sin(ai)
      ];
    };
    let d = 'M ';
    for (let i=0;i<5;i++){
      const [x1,y1,x2,y2] = k(i);
      d += `${x1} ${y1} L ${x2} ${y2} `;
    }
    d += 'Z';
    g('path', { d, fill:'#fff', opacity:'0.85' }, emblem);
  }
  svg.appendChild(emblem);

  // ----- Energy / sabers with glow ------------------------------------------
  const sabers = (form.sabers_desc || '').toLowerCase();
  if (sabers.includes('twin') || sabers.includes('cross') || sabers.includes('saber') || sabers.includes('beam')) {
    const L = R * 0.58;
    const w = Math.max(3, size*0.006);
    const mk = (x1,y1,x2,y2, rot=0) => {
      const group = g('g', { filter:'url(#glow)', opacity:'0.95' });
      // soft halo
      g('line', { x1, y1, x2, y2, stroke:'#ffffff', 'stroke-width': w*2.2, 'stroke-linecap':'round', opacity:'0.25' }, group);
      // core
      g('line', { x1, y1, x2, y2, stroke:'url(#beam)', 'stroke-width': w, 'stroke-linecap':'round' }, group);
      return group;
    };
    mk(R - L*0.7, R + L*0.7, R + L*0.7, R - L*0.7);
    mk(R + L*0.7, R + L*0.7, R - L*0.7, R - L*0.7);
  }

  // ----- Fine ring highlight -------------------------------------------------
  g('circle', {
    cx:R, cy:R, r:R*0.84, fill:'none',
    stroke:'rgba(255,255,255,0.35)', 'stroke-width': Math.max(1, size*0.003)
  });

  return svg;
}

  // --- view state ------------------------------------------------------------
  let view = { x:0, y:0, scale:1, rotation:0, minScale:0.1, maxScale:5, width:640, height:640 };
  function loadViewState(){ try{ const s = storage.get(STORAGE_KEYS.VIEW); if (s) view = { ...view, ...JSON.parse(s) }; } catch {} }
  function saveViewState(){ storage.set(STORAGE_KEYS.VIEW, JSON.stringify(view)); }
  function updatePreview() {
    const stage = byId('stage'); const inner = byId('inner'); const r = stage.getBoundingClientRect();
    inner.style.transform =
      `translate(${r.width/2 + view.x}px, ${r.height/2 + view.y}px)
       rotate(${view.rotation}deg)
       scale(${view.scale})
       translate(${-view.width/2}px, ${-view.height/2}px)`;
    byId('hudZoom').textContent = `${Math.round(view.scale * 100)}%`;
    byId('hudSize').textContent = `${Math.round(r.width)}×${Math.round(r.height)}px`;
    saveViewState();
  }

  // --- preview & prompt ------------------------------------------------------
  function generatePreview() {
    const form = readForm();
    const svg = generateSvg(form);
    svg.querySelectorAll('path, circle, line, polygon').forEach(el => {
      if (!el.hasAttribute('vector-effect')) el.setAttribute('vector-effect', 'non-scaling-stroke');
    });
    const inner = byId('inner'); inner.innerHTML = ''; inner.appendChild(svg);
    updatePreview(); generatePrompt();
    byId('live').textContent = 'Preview updated';
  }
  function generatePrompt() {
    const f = readForm();
    const detail = +f.detail_level || 7, age = +f.age_patina || 2;
    const detailTerms = detail > 7 ? 'highly detailed, intricate craftsmanship'
                      : detail > 4 ? 'moderate detail, quality craftsmanship'
                      : 'clean, minimalist design';
    const ageTerms = age > 7 ? 'ancient, heavily weathered, archaeological artifact'
                    : age > 4 ? 'aged, battle-worn, historical piece'
                    : 'pristine, newly forged';
    const txt = `
Professional medallion design render, ${f.style_keywords}.

STRUCTURE & MATERIALS:
• Base: Circular pendant, ${f.rim_finish} rim with ${f.plate_color} central plate
• Surface: ${f.material_finish} finish, ${ageTerms}
• Text: Raised inscription "${f.text_top}" in ${f.text_colors}
• Border: ${f.outline_color} accent lighting

CENTRAL DESIGN:
• Primary: ${f.state_shape} featuring ${f.main_symbol} (${f.symbol_color})
• Details: ${f.badge_elements}
• Secondary: ${f.secondary_symbol}
• Script: ${f.aurebesh_style}

EFFECTS & LIGHTING:
• Energy: ${f.sabers_desc}
• Mood: ${f.lighting_mood} lighting with ${detailTerms}
• Quality: Photorealistic rendering, studio lighting, premium materials

Technical: 4K resolution, physically accurate materials, professional product photography style.`.trim();
    byId('out').value = txt;
  }

  // --- interactions ----------------------------------------------------------
  function initInteractions() {
    const stage = byId('stage');
    let pointers = new Map(), lastCenter = null, lastDist = null;

    stage.addEventListener('pointerdown', e => { stage.setPointerCapture?.(e.pointerId); pointers.set(e.pointerId, {x:e.clientX,y:e.clientY}); });
    ['pointerup','pointercancel'].forEach(ev => stage.addEventListener(ev, e => {
      stage.releasePointerCapture?.(e.pointerId); pointers.delete(e.pointerId);
      if (pointers.size === 0) { lastCenter = lastDist = null; }
    }));
    stage.addEventListener('pointermove', e => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
      const pts = [...pointers.values()];
      if (pts.length === 1) {
        const p = pts[0];
        if (lastCenter) { view.x += p.x - lastCenter.x; view.y += p.y - lastCenter.y; updatePreview(); }
        lastCenter = {...p};
      } else if (pts.length === 2) {
        const c = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
        const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
        if (lastCenter && lastDist) {
          view.x += c.x - lastCenter.x; view.y += c.y - lastCenter.y;
          const newScale = clamp(view.scale * (d/lastDist), view.minScale, view.maxScale);
          const rect = stage.getBoundingClientRect();
          const zx = c.x - rect.left - rect.width/2 - view.x;
          const zy = c.y - rect.top  - rect.height/2 - view.y;
          const ratio = newScale / view.scale;
          view.x -= zx * (ratio - 1); view.y -= zy * (ratio - 1); view.scale = newScale;
          updatePreview();
        }
        lastCenter = c; lastDist = d;
      }
    });
    stage.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -e.deltaY * (e.ctrlKey || e.metaKey ? 0.003 : 0.002);
      const newScale = clamp(view.scale * (1 + delta), view.minScale, view.maxScale);
      const rect = stage.getBoundingClientRect();
      const zx = e.clientX - rect.left - rect.width/2 - view.x;
      const zy = e.clientY - rect.top  - rect.height/2 - view.y;
      const ratio = newScale / view.scale;
      view.x -= zx * (ratio - 1); view.y -= zy * (ratio - 1); view.scale = newScale;
      updatePreview();
    }, { passive:false });

    stage.addEventListener('dblclick', fitToView);
    byId('fit').addEventListener('click', fitToView);
    byId('fillView').addEventListener('click', fillToView);
    byId('resetView').addEventListener('click', resetView);
    byId('rotateView').addEventListener('click', rotateView);

    byId('sizeSelect').addEventListener('change', e => {
      const n = parseInt(e.target.value) || 640;
      view.width = view.height = n;
      generatePreview();
      setTimeout(fitToView, 50);
    });
  }
  function fitToView() {
    const rect = byId('stage').getBoundingClientRect(), m = 40;
    view.scale = Math.min((rect.width - m) / view.width, (rect.height - m) / view.height);
    view.x = view.y = 0; updatePreview(); showToast('Fitted to view');
  }
  function fillToView() {
    const rect = byId('stage').getBoundingClientRect();
    view.scale = Math.max(rect.width / view.width, rect.height / view.height);
    view.x = view.y = 0; updatePreview(); showToast('Filled viewport');
  }
  function resetView(){ view.x=0; view.y=0; view.scale=1; view.rotation=0; updatePreview(); showToast('View reset'); }
  function rotateView(){ view.rotation=(view.rotation+45)%360; updatePreview(); showToast(`Rotated to ${view.rotation}°`); }

  // --- swatches --------------------------------------------------------------
  function initSwatches() {
    [{containerId:'rim_swatches',inputId:'rim_finish'},{containerId:'plate_swatches',inputId:'plate_color'}]
    .forEach(({containerId,inputId}) => {
      const wrap = byId(containerId), input = byId(inputId);
      if (!wrap || !input) return;
      wrap.addEventListener('click', e => {
        const sw = e.target.closest('.swatch'); if (!sw) return;
        wrap.querySelectorAll('.swatch').forEach(s => s.setAttribute('aria-pressed','false'));
        sw.setAttribute('aria-pressed','true');
        input.value = sw.dataset.val || '';
        debouncedGenerate();
        showToast(`Applied ${sw.textContent} preset`);
      });
    });
  }

  // --- exports ---------------------------------------------------------------
  function initExports() {
    byId('copyBtn').addEventListener('click', async () => {
      const t = byId('out').value; if (!t.trim()) return showToast('No content to copy','error');
      try { await navigator.clipboard.writeText(t); showToast('Prompt copied to clipboard'); }
      catch { showToast('Copy failed','error'); }
    });
    byId('downloadBtn').addEventListener('click', () => {
      const t = byId('out').value; if (!t.trim()) return showToast('No content to download','error');
      const blob = new Blob([t], {type:'text/plain'}), url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=`medallion_prompt_${Date.now()}.txt`; a.click(); URL.revokeObjectURL(url);
      showToast('Prompt downloaded');
    });

    const getSvgXml = () => {
      const svg = byId('inner').querySelector('svg'); if (!svg) return null;
      const clone = svg.cloneNode(true), wrap = document.createElementNS(NS,'g');
      while (clone.firstChild) wrap.appendChild(clone.firstChild);
      if (view.rotation) wrap.setAttribute('transform', `rotate(${view.rotation} ${view.width/2} ${view.height/2})`);
      clone.appendChild(wrap); clone.setAttribute('xmlns', NS);
      return `<?xml version="1.0" encoding="UTF-8"?>\n${clone.outerHTML}`;
    };

    byId('copySvgBtn').addEventListener('click', async () => {
      const xml = getSvgXml(); if (!xml) return showToast('No SVG to copy','error');
      try { await navigator.clipboard.writeText(xml); showToast('SVG copied to clipboard'); }
      catch { showToast('SVG copy failed','error'); }
    });
    byId('downloadSvgBtn').addEventListener('click', () => {
      const xml = getSvgXml(); if (!xml) return showToast('No SVG to export','error');
      const blob = new Blob([xml], {type:'image/svg+xml'}), url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download=`medallion_${view.width}x${view.height}.svg`; a.click(); URL.revokeObjectURL(url);
      showToast('SVG downloaded');
    });
    byId('downloadPngBtn').addEventListener('click', () => {
      const xml = getSvgXml(); if (!xml) return showToast('No image to export','error');
      const blob = new Blob([xml], {type:'image/svg+xml'}), url = URL.createObjectURL(blob), img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas'), scale = 2;
        canvas.width = view.width * scale; canvas.height = view.height * scale;
        const ctx = canvas.getContext('2d'); ctx.scale(scale, scale); ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        canvas.toBlob(b => {
          if (!b) return showToast('PNG export failed','error');
          const u = URL.createObjectURL(b), a = document.createElement('a');
          a.href=u; a.download=`medallion_${view.width}x${view.height}_${Date.now()}.png`; a.click(); URL.revokeObjectURL(u);
          showToast('PNG exported successfully');
        }, 'image/png', 0.95);
      };
      img.onerror = () => { URL.revokeObjectURL(url); showToast('PNG export failed','error'); };
      img.crossOrigin = 'anonymous'; img.src = url;
    });
  }

  // --- preset actions --------------------------------------------------------
  function initPresetActions() {
    byId('addPresetBtn').addEventListener('click', () => {
      const form = readForm(); const name = form.text_top.trim() || 'Custom Preset';
      const short = name.split(' ').slice(0,3).join(' ').substring(0,25);
      const preset = {
        id:`user_${Date.now()}_${Math.random().toString(36).slice(2,11)}`,
        name:short, note:'Custom design • User created',
        thumb:(short.split(' ').map(w=>w[0]).join('') || 'CUST').toUpperCase().slice(0,4),
        form:{...form}
      };
      const list = getPresets(); list.push(preset); setPresets(list); showToast(`Saved "${short}"`);
    });
    byId('randBtn').addEventListener('click', () => {
      const pick = a => a[Math.floor(Math.random()*a.length)];
      const rf = {
        ...getDefaultForm(),
        text_top: pick(['COSMIC GUARDIAN','STELLAR KNIGHT','VOID WALKER','STAR FORGE','GALAXY DEFENDER']),
        rim_finish: pick(['polished steel','brushed silver','antique gold','weathered bronze','blackened iron']),
        plate_color: pick(['deep obsidian','midnight navy','crimson red','forest green','royal purple']),
        main_symbol: pick(['stylized phoenix','cosmic spiral','star constellation','dragon insignia','celestial crown']),
        symbol_color: pick(['gradient gold to crimson','electric blue glow','silver with shadows','prismatic rainbow','deep emerald']),
        flip_arc: pick(['auto','normal','flipped']),
        lighting_mood: pick(['dramatic','soft','ethereal','moody'])
      };
      writeForm(rf); generatePreview(); showToast('Random configuration generated');
    });
  }

  // --- JSON modal ------------------------------------------------------------
  function initJsonModal() {
    const modal = byId('jsonModal'), textarea = byId('jsonArea');
    byId('exportJsonBtn').addEventListener('click', () => {
      textarea.value = JSON.stringify({ version:'2.0', timestamp:new Date().toISOString(), form:readForm(), presets:getPresets(), view }, null, 2);
      modal.showModal(); showToast('Export data prepared');
    });
    byId('importJsonBtn').addEventListener('click', () => { textarea.value=''; textarea.placeholder='Paste your configuration JSON here...'; modal.showModal(); });
    byId('validateJson').addEventListener('click', () => {
      try {
        const d = JSON.parse(textarea.value || '{}'); showToast('JSON is valid','success');
        const info = []; if (d.form) info.push('Form configuration'); if (d.presets) info.push(`${d.presets.length} presets`); if (d.view) info.push('View settings');
        if (info.length) showToast(`Will import: ${info.join(', ')}`,'info');
      } catch (e) { showToast(`Invalid JSON: ${e.message}`,'error'); }
    });
    byId('applyJson').addEventListener('click', () => {
      try {
        const d = JSON.parse(textarea.value || '{}');
        if (d.form) writeForm({ ...getDefaultForm(), ...d.form });
        if (Array.isArray(d.presets)) setPresets(d.presets);
        if (d.view) view = { ...view, ...d.view };
        generatePreview(); renderPresets(); modal.close(); showToast('Configuration imported successfully');
      } catch (e) { showToast(`Import failed: ${e.message}`,'error'); }
    });
    byId('copyJson').addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(textarea.value); showToast('JSON copied to clipboard'); }
      catch { showToast('Copy failed','error'); }
    });
    byId('closeJson').addEventListener('click', () => modal.close());
  }

  // --- fullscreen ------------------------------------------------------------
  function initFullscreen() {
    const modal = byId('fullscreenModal'), inner = byId('fullscreenInner');
    byId('fullscreenBtn').addEventListener('click', () => {
      const cur = byId('inner').querySelector('svg'); if (!cur) return showToast('No preview to show','error');
      const clone = cur.cloneNode(true); inner.innerHTML=''; inner.appendChild(clone);
      const stageSize = 600, scale = Math.min(stageSize / view.width, stageSize / view.height) * 0.9;
      inner.style.transform = `translate(${stageSize/2}px, ${stageSize/2}px) scale(${scale}) translate(${-view.width/2}px, ${-view.height/2}px)`;
      modal.showModal();
    });
    byId('closeFullscreen').addEventListener('click', () => modal.close());
  }

  // --- animation -------------------------------------------------------------
  let animationId = null, animating = false;
  function initAnimation() {
    byId('animateBtn').addEventListener('click', () => { animating ? stopAnimation() : startAnimation(); });
  }
  function startAnimation() {
    if (animating) return; animating = true;
    const btn = byId('animateBtn'); btn.querySelector('.material-icons-round').textContent = 'pause_circle'; btn.title = 'Stop animation';
    let start = Date.now();
    const loop = () => {
      if (!animating) return;
      const t = (Date.now() - start) / 1000;
      view.rotation = (t * 30) % 360; updatePreview();
      animationId = requestAnimationFrame(loop);
    };
    loop(); showToast('Animation started');
  }
  function stopAnimation() {
    animating = false; if (animationId) cancelAnimationFrame(animationId), animationId = null;
    const btn = byId('animateBtn'); btn.querySelector('.material-icons-round').textContent = 'play_circle'; btn.title = 'Start animation';
    showToast('Animation stopped');
  }

  // --- reactivity ------------------------------------------------------------
  const debouncedGenerate = (() => { let t; return (d=300) => { clearTimeout(t); t = setTimeout(() => generatePreview(), d); }; })();
  function initFormReactivity() {
    FORM_FIELDS.forEach(id => {
      const el = byId(id); if (!el) return;
      const evts = el.type === 'range' ? ['input'] : ['input','change'];
      evts.forEach(e => el.addEventListener(e, () => debouncedGenerate(el.type === 'range' ? 100 : 300)));
    });
    byId('clearBtn').addEventListener('click', () => {
      if (confirm('Reset all settings to defaults?')) { writeForm(getDefaultForm()); generatePreview(); showToast('Settings reset to defaults'); }
    });
    byId('gen').addEventListener('click', () => { generatePreview(); showToast('Preview regenerated'); });
  }

  // --- keyboard shortcuts (querySelector for singles) ------------------------
  function initKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey)) {
        switch (e.key.toLowerCase()) {
          case 'enter': e.preventDefault(); generatePreview(); showToast('Generated via shortcut'); break;
          case 'r': if (e.shiftKey){ e.preventDefault(); resetView(); } break;
          case 's': if (e.shiftKey){ e.preventDefault(); byId('addPresetBtn').click(); } break;
          case 'f': e.preventDefault(); fitToView(); break;
        }
      }
      if (e.key === 'Tab') {
        const activeTab = document.querySelector('.tab[aria-selected="true"]');
        if (activeTab && document.activeElement === activeTab) {
          const activePanel = document.querySelector('.tabpanel:not([hidden])');
          const firstInput = activePanel?.querySelector('input, select, textarea');
          if (firstInput) { e.preventDefault(); firstInput.focus(); }
        }
      }
    });
  }

  // --- responsive ------------------------------------------------------------
  function initResponsive() {
    const ro = new ResizeObserver(entries => { for (const ent of entries) if (ent.target.id === 'stage') updatePreview(); });
    ro.observe(byId('stage'));
  }

  // --- search ----------------------------------------------------------------
  function initSearch() {
    const input = byId('profileSearch');
    input.addEventListener('input', () => { clearTimeout(input.searchTimeout); input.searchTimeout = setTimeout(renderPresets, 200); });
    input.addEventListener('keydown', e => { if (e.key === 'Escape'){ input.value=''; renderPresets(); input.blur(); } });
  }

  // --- boot ------------------------------------------------------------------
  function init() {
    try {
      loadViewState();
      initTheme();
      initTabs();
      initSwatches();
      initInteractions();
      initExports();
      initPresetActions();
      initJsonModal();
      initFullscreen();
      initAnimation();
      initFormReactivity();
      initKeyboardShortcuts();
      initResponsive();
      initSearch();

      writeForm(currentForm);
      renderPresets();

      const sizeSelect = byId('sizeSelect');
      view.width = view.height = parseInt(sizeSelect.value) || 640;

      setTimeout(() => {
        generatePreview();
        fitToView();
        showToast('Medallion Forge Enhanced ready');
      }, 100);
    } catch (err) {
      console.error('Initialization error:', err);
      showToast('Initialization error - check console', 'error');
    }
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
})();
</script>