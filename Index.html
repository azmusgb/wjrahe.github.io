<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Medallion SVG Preview – Responsive</title>
<style>
  :root{
    --bg: #0e0f12;
    --panel: #151820;
    --ink: #e7ecf3;
    --ink-dim: #a9b3c2;
    --accent: #6aa3ff;
    --accent-2:#51d0a1;
    --border: #262b36;
    --shadow: 0 6px 24px rgba(0,0,0,.35);
    --radius: 12px;
    --thumb: #2b3242;
  }
  @media (prefers-color-scheme: light) {
    :root{
      --bg: #f7f8fb; --panel:#ffffff; --ink:#0d1220; --ink-dim:#475066;
      --border:#e7ebf3; --thumb:#e9edf6;
    }
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  .wrap{
    min-height:100dvh; display:grid; gap:12px; padding:12px;
    grid-template-rows:auto 1fr auto;
  }
  header,footer{
    background:var(--panel); border:1px solid var(--border);
    border-radius:var(--radius); padding:10px 12px; box-shadow:var(--shadow);
  }
  header{ display:flex; align-items:center; gap:12px; flex-wrap:wrap}
  header .title{font-weight:650; letter-spacing:.2px}
  header .row{display:flex; gap:8px; flex-wrap:wrap; margin-left:auto}
  button, .seg input[type=range]{
    -webkit-tap-highlight-color:transparent;
  }
  .btn{
    border:1px solid var(--border); background:#1b2030; color:var(--ink);
    padding:8px 10px; border-radius:10px; cursor:pointer;
  }
  @media (prefers-color-scheme: light){
    .btn{background:#f3f6ff}
  }
  .btn:hover{border-color:#3a4152}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .seg{display:flex; align-items:center; gap:8px}
  .seg label{color:var(--ink-dim); font-size:12px}

  .stage{
    background:var(--panel); border:1px solid var(--border);
    border-radius:var(--radius); box-shadow:var(--shadow);
    position:relative; overflow:hidden; min-height:60dvh;
    /* helpful for very small phones */
  }

  /* Scrollable container for overflow safety on tiny screens */
  .viewport{
    width:100%; height:100%; touch-action:none; /* we implement panning/zooming */
    position:relative; background:
      radial-gradient(circle at 25% 25%, #10131a 0 25%, transparent 26%),
      radial-gradient(circle at 75% 75%, #10131a 0 25%, transparent 26%),
      linear-gradient(transparent, transparent);
  }
  @media (prefers-color-scheme: light){
    .viewport{background:
      radial-gradient(circle at 25% 25%, #f3f6ff 0 25%, transparent 26%),
      radial-gradient(circle at 75% 75%, #f3f6ff 0 25%, transparent 26%);}
  }

  /* The layer we transform for pan/zoom */
  .content{
    position:absolute; top:50%; left:50%;
    transform-origin: 0 0; /* we reposition manually */
    will-change: transform;
  }

  /* Overlay HUD */
  .hud{
    position:absolute; right:10px; bottom:10px; display:flex; gap:8px; flex-wrap:wrap;
  }
  .hud .chip{
    background:#10131a; border:1px solid var(--border); color:var(--ink-dim);
    padding:6px 8px; border-radius:10px; font-size:12px
  }
  @media (prefers-color-scheme: light){
    .hud .chip{background:#fff}
  }

  .tools{
    display:flex; gap:8px; flex-wrap:wrap;
  }
  .tools .btn{display:flex; align-items:center; gap:6px}
  .tools .btn .dot{width:6px; height:6px; border-radius:50%; background:var(--accent-2)}

  .seg input[type=range]{
    appearance:none; width:120px; height:8px; background:var(--thumb);
    border-radius:999px; outline:none;
  }
  .seg input[type=range]::-webkit-slider-thumb{
    appearance:none; width:18px; height:18px; border-radius:50%;
    background:var(--accent); border:0; box-shadow:0 2px 6px rgba(0,0,0,.35)
  }
  .seg output{
    min-width:3ch; text-align:right; color:var(--ink-dim); font-variant-numeric:tabular-nums;
  }

  footer{
    display:flex; align-items:center; justify-content:space-between; gap:10px; color:var(--ink-dim)
  }
  .badge{color:var(--accent)}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Medallion Preview</div>
      <div class="row">
        <div class="tools">
          <button class="btn" id="fit">Fit</button>
          <button class="btn" id="fill">Fill</button>
          <button class="btn" id="reset">Reset</button>
          <button class="btn" id="export">Export PNG</button>
        </div>
        <div class="seg">
          <label for="zoom">Zoom</label>
          <input id="zoom" type="range" min="10" max="800" value="100" />
          <output id="zoomOut">100%</output>
        </div>
      </div>
    </header>

    <main class="stage">
      <div class="viewport" id="viewport" aria-label="SVG preview surface">
        <div class="content" id="content">
          <!-- Your SVG goes here. Make sure it has a proper viewBox. -->
          <svg id="medallion" viewBox="0 0 1024 1024" width="1024" height="1024" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Medallion sample" preserveAspectRatio="xMidYMid meet">
            <defs>
              <radialGradient id="g" cx=".5" cy=".5" r=".55">
                <stop offset="0" stop-color="#ffffff"/>
                <stop offset=".55" stop-color="#d8e7ff"/>
                <stop offset="1" stop-color="#9cc0ff"/>
              </radialGradient>
              <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
                <feGaussianBlur stdDeviation="1.2" />
              </filter>
            </defs>
            <rect x="0" y="0" width="1024" height="1024" fill="#0d1020"/>
            <g transform="translate(512,512)">
              <circle r="360" fill="url(#g)" />
              <g filter="url(#soft)">
                <circle r="330" fill="none" stroke="#1c2a5f" stroke-width="8"/>
                <circle r="270" fill="none" stroke="#1c2a5f" stroke-width="6" stroke-dasharray="8 12"/>
                <circle r="180" fill="none" stroke="#1c2a5f" stroke-width="5" stroke-dasharray="4 8"/>
              </g>
              <!-- sample emblem -->
              <g aria-label="emblem">
                <path d="M0 -220 L40 -40 L220 -40 L70 30 L110 210 L0 110 L-110 210 L-70 30 L-220 -40 L-40 -40 Z"
                      fill="#172045" stroke="#0c132e" stroke-width="8"/>
                <path d="M0 -190 L33 -45 L185 -45 L60 20 L95 165 L0 90 L-95 165 L-60 20 L-185 -45 L-33 -45 Z"
                      fill="#243568" />
              </g>
            </g>
          </svg>
        </div>
        <div class="hud" aria-hidden="true">
          <div class="chip" id="hud-size">–</div>
          <div class="chip" id="hud-zoom">–</div>
        </div>
      </div>
    </main>

    <footer>
      <div>Drag to pan • Wheel/Pinch to zoom • <span class="badge">Mobile & Desktop</span></div>
      <div id="msg"></div>
    </footer>
  </div>

<script>
(function(){
  const viewport = document.getElementById('viewport');
  const content  = document.getElementById('content');
  const svg      = document.getElementById('medallion');
  const btnFit   = document.getElementById('fit');
  const btnFill  = document.getElementById('fill');
  const btnReset = document.getElementById('reset');
  const btnExport= document.getElementById('export');
  const zoomRange= document.getElementById('zoom');
  const zoomOut  = document.getElementById('zoomOut');
  const hudSize  = document.getElementById('hud-size');
  const hudZoom  = document.getElementById('hud-zoom');
  const msg      = document.getElementById('msg');

  // --- Utilities ------------------------------------------------------------
  const state = {
    x: 0, y: 0, scale: 1,
    minScale: .05, maxScale: 8,
    contentW: 1024, contentH: 1024
  };

  // Ensure the SVG has a viewBox; it’s critical for crisp scaling.
  function ensureViewBox(el){
    const vb = el.getAttribute('viewBox');
    if(!vb){
      const w = parseFloat(el.getAttribute('width')) || 1024;
      const h = parseFloat(el.getAttribute('height')) || 1024;
      el.setAttribute('viewBox', `0 0 ${w} ${h}`);
    }
    const [x,y,w,h] = el.getAttribute('viewBox').split(/\s+/).map(Number);
    state.contentW = w; state.contentH = h;
  }
  ensureViewBox(svg);

  const ro = new ResizeObserver(updateFitBounds);
  ro.observe(viewport);

  let view = { w:0, h:0, cx:0, cy:0 };

  function updateFitBounds(){
    const rect = viewport.getBoundingClientRect();
    view.w = rect.width; view.h = rect.height;
    view.cx = view.w/2; view.cy = view.h/2;
    hudSize.textContent = `${Math.round(view.w)}×${Math.round(view.h)}px`;
    render();
  }

  function setTransform(x,y,scale){
    state.x = x; state.y = y; state.scale = clamp(scale, state.minScale, state.maxScale);
    render();
  }

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  function render(){
    content.style.transform = `translate(${view.cx + state.x}px, ${view.cy + state.y}px) scale(${state.scale}) translate(${-state.contentW/2}px, ${-state.contentH/2}px)`;
    const pct = Math.round(state.scale*100);
    zoomRange.value = pct; zoomOut.value = pct + '%';
    hudZoom.textContent = `Zoom ${pct}%`;
  }

  // Fit and Fill compute scales based on viewBox → viewport
  function scaleForFit(){
    return Math.min(view.w/state.contentW, view.h/state.contentH);
  }
  function scaleForFill(){
    return Math.max(view.w/state.contentW, view.h/state.contentH);
  }
  function center(){
    setTransform(0,0,state.scale);
  }

  // Public actions
  function doFit(){ setTransform(0,0, scaleForFit()); }
  function doFill(){ setTransform(0,0, scaleForFill()); }
  function doReset(){ setTransform(0,0, 1); }

  btnFit.addEventListener('click', doFit);
  btnFill.addEventListener('click', doFill);
  btnReset.addEventListener('click', doReset);

  // Zoom via range
  zoomRange.addEventListener('input', (e)=>{
    const targetScale = parseInt(e.target.value,10)/100;
    // zoom to center, keep current pan roughly consistent
    const k = targetScale/state.scale;
    setTransform(state.x*k, state.y*k, targetScale);
  });

  // --- Interaction: mouse/touch/trackpad -----------------------------------
  let dragging=false, lastX=0, lastY=0;
  viewport.addEventListener('pointerdown', (e)=>{
    dragging=true; viewport.setPointerCapture(e.pointerId);
    lastX=e.clientX; lastY=e.clientY;
  });
  viewport.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    lastX=e.clientX; lastY=e.clientY;
    setTransform(state.x+dx, state.y+dy, state.scale);
  });
  const stopDrag=()=>{dragging=false};
  viewport.addEventListener('pointerup', stopDrag);
  viewport.addEventListener('pointercancel', stopDrag);
  viewport.addEventListener('pointerleave', stopDrag);

  // Wheel/trackpad zoom (Ctrl/Cmd+wheel or pinch on trackpads)
  viewport.addEventListener('wheel', (e)=>{
    e.preventDefault();
    // zoom toward cursor
    const zoomIntensity = (e.ctrlKey || e.metaKey) ? 0.0025 : 0.0015;
    const delta = -e.deltaY * zoomIntensity;
    const newScale = clamp(state.scale * (1 + delta), state.minScale, state.maxScale);

    const rect = viewport.getBoundingClientRect();
    const mx = e.clientX - rect.left - view.cx - state.x;
    const my = e.clientY - rect.top  - view.cy - state.y;

    // adjust pan so the point under cursor stays under cursor
    const k = newScale/state.scale;
    const nx = state.x - mx*(k-1);
    const ny = state.y - my*(k-1);
    setTransform(nx, ny, newScale);
  }, {passive:false});

  // Pinch zoom on touch (two-finger)
  let pinchDist = 0, pinchMid = null;
  viewport.addEventListener('touchstart', (e)=>{
    if(e.touches.length===2){
      pinchDist = dist(e.touches[0], e.touches[1]);
      pinchMid  = mid(e.touches[0], e.touches[1]);
    }
  }, {passive:true});
  viewport.addEventListener('touchmove', (e)=>{
    if(e.touches.length===2){
      e.preventDefault();
      const d = dist(e.touches[0], e.touches[1]);
      const rect = viewport.getBoundingClientRect();
      const m = mid(e.touches[0], e.touches[1]);
      const mx = m.x - rect.left - view.cx - state.x;
      const my = m.y - rect.top  - view.cy - state.y;
      const k = d/pinchDist;
      const newScale = clamp(state.scale*k, state.minScale, state.maxScale);
      const adj = newScale/state.scale;
      const nx = state.x - mx*(adj-1);
      const ny = state.y - my*(adj-1);
      setTransform(nx, ny, newScale);
      pinchDist = d;
    }
  }, {passive:false});

  function dist(a,b){const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy)}
  function mid(a,b){return {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2}}

  // --- Export PNG (hi-DPI aware) -------------------------------------------
  btnExport.addEventListener('click', async ()=>{
    try{
      const {width, height} = svg.viewBox.baseVal;
      const scale = Math.min(4096/Math.max(width,height), 4); // keep PNG sane
      const pxW = Math.round(width * scale * (window.devicePixelRatio || 1));
      const pxH = Math.round(height* scale * (window.devicePixelRatio || 1));

      // serialize SVG
      const s = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([s], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(blob);

      const img = new Image();
      // important for cross-origin gradient/filter correctness
      img.decoding = 'async';
      img.onload = ()=>{
        const c = document.createElement('canvas');
        c.width = pxW; c.height = pxH;
        const ctx = c.getContext('2d', {alpha:false});
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, pxW, pxH);
        URL.revokeObjectURL(url);
        c.toBlob((pngBlob)=>{
          const a = document.createElement('a');
          a.href = URL.createObjectURL(pngBlob);
          a.download = 'medallion.png';
          a.click();
          setMsg('Exported PNG', 1800);
        }, 'image/png');
      };
      img.onerror = ()=>{ URL.revokeObjectURL(url); setMsg('Export failed', 2500) };
      img.src = url;
    }catch(err){
      console.error(err); setMsg('Export failed', 2500);
    }
  });

  function setMsg(text, ms=1500){
    msg.textContent = text;
    if(ms){
      setTimeout(()=>{ if(msg.textContent===text) msg.textContent=''; }, ms);
    }
  }

  // Initial fit on load
  window.addEventListener('load', ()=>{
    doFit();
    // If you inject a new SVG at runtime, call ensureViewBox(newSvg); doFit();
  });

  // Keyboard helpers
  window.addEventListener('keydown', (e)=>{
    if(e.key==='0'){ doFit(); }
    if(e.key==='1'){ doReset(); }
    if(e.key==='f'){ doFill(); }
    if(e.key==='=' || e.key==='+'){ nudgeZoom(1.1) }
    if(e.key==='-' ){ nudgeZoom(1/1.1) }
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){
      const step = 20;
      const dx = (e.key==='ArrowLeft'?-step: e.key==='ArrowRight'?step:0);
      const dy = (e.key==='ArrowUp'?-step: e.key==='ArrowDown'?step:0);
      setTransform(state.x+dx, state.y+dy, state.scale);
    }
  });
  function nudgeZoom(k){
    const newScale = clamp(state.scale*k, state.minScale, state.maxScale);
    const sMul = newScale/state.scale;
    setTransform(state.x*sMul, state.y*sMul, newScale);
  }
})();
</script>
</body>
</html>